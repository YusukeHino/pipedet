
import json
import os
import glob
import argparse
import xml.etree.ElementTree as ET

import cv2

from pipedet.structure.large_image import LargeImage

def xml_to_csv(xml_dir, output_file, tag):
    """Reads all XML files, generated by labelImg, from a directory and generates a single CSV file"""
    for xml_file in glob.glob(xml_dir + '/*.xml'):
        tree = ET.parse(xml_file)
        root = tree.getroot()
        width = float(root.find('size')[0].text)
        height = float(root.find('size')[1].text)
        for member in root.findall('object'):
            value = (tag,
                "gs://mirror-images/img/"+root.find('filename').text,
                member[0].text,
                float(member[4][0].text)/width, float(member[4][1].text)/height,None,None,
                float(member[4][2].text)/width, float(member[4][3].text)/height,None,None)

if __name__ == '__main__':
    DESIRED_WIDTH = 1024
    DESIRED_HEIGHT = 1024
    DATA_ROOT = os.environ["HOME"] + "/data"
    INPUT_DATA_ROOT = DATA_ROOT + "/for_rsm_detection/separated"
    OUTPUT_DATA_ROOT = DATA_ROOT + "/for_rsm_detection/cropped_" + str(DESIRED_WIDTH) + "_" + str(DESIRED_HEIGHT)

    input_images_root_list = [i for i in os.listdir(INPUT_DATA_ROOT)]
    for images_dir in input_images_root_list:
        if images_dir.endswith("train"):
            tag = "TRAIN"
            output_dir = "train"
        elif images_dir.endswith("validate"):
            tag = "VALIDATE"
            output_dir = "validate"
        elif images_dir.endswith("eval"):
            tag = "TEST"
            output_dir = "test"
        else:
            continue
        full_path_input_images_dir = INPUT_DATA_ROOT + "/" + images_dir
        full_path_output = OUTPUT_DATA_ROOT + "/" + output_dir
        try:
            os.makedirs(full_path_output)
        except FileExistsError:
            pass

        for xml_file in glob.glob(full_path_input_images_dir + '/*.xml'):
            tree = ET.parse(xml_file)
            root = tree.getroot()
            image_name = root.find('filename').text
            full_path_input_image = full_path_input_images_dir + "/" + image_name
            bboxes = []
            for member in root.findall('object'):
                bbox = [0] * 4
                bbox[0] = int(member.find('bndbox').find('xmin').text)
                bbox[1] = int(member.find('bndbox').find('ymin').text)
                bbox[2] = int(member.find('bndbox').find('xmax').text)
                bbox[3] = int(member.find('bndbox').find('ymax').text)
                bboxes.append(bbox)
            large_image = LargeImage(cv2.imread(full_path_input_image), bboxes)
            images_with_bboxes = large_image.make_dataset(DESIRED_WIDTH, DESIRED_HEIGHT)
            for i, image_with_bboxes in enumerate(images_with_bboxes):
                out_image_name = image_name[:-4] + "_" + str(i) + image_name[-4:]
                full_path_output_image = full_path_output + "/" + out_image_name
                cv2.imwrite(full_path_output_image, image_with_bboxes.image)

                out_xml_name = out_image_name[:-4] + ".xml"
                full_path_out_xml = full_path_output + "/" + out_xml_name
                
                tag_annotation = ET.Element('annotation')
                tag_filename = ET.SubElement(tag_annotation, 'filename')
                tag_filename.text = out_image_name
                tag_size = ET.SubElement(tag_annotation, 'size')
                tag_width = ET.SubElement(tag_size, 'width')
                tag_width.text = str(image_with_bboxes.width)
                tag_height = ET.SubElement(tag_size, 'height')
                tag_height.text = str(image_with_bboxes.height)

                for bbox_converted in image_with_bboxes.bboxes:
                    tag_object = ET.SubElement(tag_annotation, 'object')
                    tag_name = ET.SubElement(tag_object, 'name')
                    tag_name.text = "mirror"
                    tag_bndbox = ET.SubElement(tag_object, 'bndbox')
                    tag_xmin = ET.SubElement(tag_bndbox, 'xmin')
                    tag_xmin.text = str(bbox_converted[0])
                    tag_ymin = ET.SubElement(tag_bndbox, 'ymin')
                    tag_ymin.text = str(bbox_converted[1])
                    tag_xmax = ET.SubElement(tag_bndbox, 'xmax')
                    tag_xmax.text = str(bbox_converted[2])
                    tag_ymax = ET.SubElement(tag_bndbox, 'ymax')
                    tag_ymax.text = str(bbox_converted[3])

                out_tree = ET.ElementTree(tag_annotation)
                out_tree.write(full_path_out_xml, encoding='UTF-8')